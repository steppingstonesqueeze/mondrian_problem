out[[length(out) + 1L]] <- list(w = ww, h = hh, area = area)
}
}
}
# de-duplicate unordered pairs
if (!length(out)) return(list())
keys <- vapply(out, function(z) paste0(z$w, "x", z$h), "")
out[!duplicated(keys)]
}
# Enumerate distinct-area subsets S with sum S == N^2 (ordered by defect).
partitions_distinct_sum <- function(N, max_sets = 200L) {
target <- N * N
A <- candidate_areas(N)
out <- list(); cur <- integer()
backtrack <- function(i, remain) {
if (length(out) >= max_sets) return()
if (remain == 0L && length(cur) >= 2L) {
out[[length(out) + 1L]] <<- sort(cur)
return()
}
if (i > length(A) || remain < 0L) return()
a <- A[i]
if (a <= remain) { cur <<- c(cur, a); backtrack(i + 1L, remain - a); cur <<- cur[-length(cur)] }
backtrack(i + 1L, remain)
}
backtrack(1L, target)
if (!length(out)) return(list())
ord <- order(vapply(out, function(s) max(s) - min(s), numeric(1)))
out[ord]
}
# ---- DLX Exact Cover (Algorithm X) ----
# Build rows for exact cover:
# - Columns 1..N^2: board cells (must be covered exactly once)
# - Columns N^2+1..N^2+R: one column per rectangle (use each rectangle exactly once)
# rects: list of list(w,h,area)
build_exact_cover_rows <- function(N, rects) {
n_cells <- N * N
rows <- list()
for (k in seq_along(rects)) {
r <- rects[[k]]
# unique orientations (avoid duplicate if w==h)
orients <- if (r$w == r$h) list(c(r$w, r$h)) else list(c(r$w, r$h), c(r$h, r$w))
for (o in orients) {
w <- o[1]; h <- o[2]
for (row in 1:(N - h + 1)) for (col in 1:(N - w + 1)) {
cells <- as.vector(outer((row - 1):(row + h - 2), (col - 1):(col + w - 2),
function(rr, cc) rr * N + cc + 1L))
rows[[length(rows) + 1L]] <- c(cells, n_cells + k)
}
}
}
rows
}
# Simple Algorithm X (sufficient for N up to ~8–10 with the arithmetic filter).
algorithm_x <- function(rows, ncols, max_solutions = 1L) {
col_rows <- vector("list", ncols)
for (ri in seq_along(rows)) for (c in rows[[ri]]) col_rows[[c]] <- c(col_rows[[c]], ri)
used_rows <- logical(length(rows))
used_cols <- logical(ncols)
solution  <- integer(0)
solutions <- list()
choose_col <- function() {
best_c <- 0L; best_len <- Inf
for (c in which(!used_cols)) {
cand <- col_rows[[c]]; cand <- cand[!used_rows[cand]]
ln <- length(cand)
if (ln < best_len) { best_len <- ln; best_c <- c }
if (best_len == 0L) break
}
best_c
}
cover <- function(ri) {
rcols <- rows[[ri]]
stashed <- vector("list", length(rcols))
for (i in seq_along(rcols)) {
c <- rcols[[i]]
if (used_cols[c]) next
used_cols[c] <<- TRUE
bad <- col_rows[[c]]; bad <- bad[!used_rows[bad]]
stashed[[i]] <- bad
used_rows[bad] <<- TRUE
}
stashed
}
uncover <- function(ri, stashed) {
rcols <- rows[[ri]]
for (i in seq_along(rcols)) {
c <- rcols[[i]]
used_cols[c] <<- FALSE
used_rows[stashed[[i]]] <<- FALSE
}
}
search <- function() {
if (all(used_cols)) {
solutions[[length(solutions) + 1L]] <<- solution
return(length(solutions) < max_solutions)
}
c <- choose_col()
if (c == 0L) return(TRUE)
candidates <- col_rows[[c]]; candidates <- candidates[!used_rows[candidates]]
if (!length(candidates)) return(TRUE)
for (ri in candidates) {
solution <<- c(solution, ri)
stash <- cover(ri)
cont <- search()
uncover(ri, stash)
solution <<- solution[-length(solution)]
if (!cont) return(FALSE)
}
TRUE
}
search()
solutions
}
# ---- Rehydrate a DLX solution into rectangle placements for plotting ----
rehydrate_solution <- function(N, rects, rows, sol_rows) {
# Build the same linear order mapping we used in build_exact_cover_rows()
inv <- vector("list", length(rows))
idx <- 0L
for (k in seq_along(rects)) {
r <- rects[[k]]
orients <- if (r$w == r$h) list(c(r$w, r$h)) else list(c(r$w, r$h), c(r$h, r$w))
for (o in orients) {
w <- o[1]; h <- o[2]
for (row in 1:(N - h + 1)) for (col in 1:(N - w + 1)) {
idx <- idx + 1L
inv[[idx]] <- list(row = row, col = col, w = w, h = h, area = r$area, id = k)
}
}
}
til <- lapply(sol_rows, function(ri) inv[[ri]])
ord <- order(vapply(til, `[[`, integer(1), "row"),
vapply(til, `[[`, integer(1), "col"))
til[ord]
}
# ---- Hybrid Mondrian Solver (Arithmetic partitions + DLX) ----
source("mondrian_utils.R")
# Helper: make sure we always get (w,h) from a factor-pair entry (robust to atomic or list)
.fp_to_wh <- function(fp) {
if (is.list(fp)) {
if (!is.null(fp$w) && !is.null(fp$h)) return(c(as.integer(fp$w), as.integer(fp$h)))
# list but unnamed: treat as vector
x <- unlist(fp, use.names = FALSE)
return(c(as.integer(x[1]), as.integer(x[2])))
} else {
# atomic numeric vector
return(c(as.integer(fp[1]), as.integer(fp[2])))
}
}
solve_mondrian <- function(N, max_partitions = 200L) {
parts <- partitions_distinct_sum(N, max_partitions)
best_defect <- Inf
best <- NULL
ncols <- N * N  # cell columns; rect columns added per instance
for (S in parts) {
defect <- max(S) - min(S)
if (defect >= best_defect) next
# For each area in S pick *one* factor pair (first available)
rects <- list()
ok <- TRUE
for (a in S) {
fps <- factor_pairs_for_area(a, N)
if (!length(fps)) { ok <- FALSE; break }
wh <- .fp_to_wh(fps[[1]])
rects[[length(rects) + 1L]] <- list(w = wh[1], h = wh[2], area = a)
}
if (!ok) next
rows <- build_exact_cover_rows(N, rects)
sols <- algorithm_x(rows, ncols + length(rects), max_solutions = 1L)
if (length(sols)) {
best_defect <- defect
best <- list(rects = rects, rows = rows, sol = sols[[1]])
break
}
}
list(best_defect = best_defect, tiling = best)
}
library(ggplot2)
plot_tiling <- function(N, tiling) {
if (is.null(tiling)) {
return(ggplot() + ggtitle("No tiling found") + theme_void())
}
rects <- tiling$rects
rows  <- tiling$rows
sol   <- tiling$sol
placed <- rehydrate_solution(N, rects, rows, sol)
df <- do.call(rbind, lapply(seq_along(placed), function(i) {
r <- placed[[i]]
data.frame(
xmin = r$col - 1, xmax = r$col - 1 + r$w,
ymin = r$row - 1, ymax = r$row - 1 + r$h,
id = factor(i), label = paste0(r$w, "x", r$h)
)
}))
ggplot(df) +
geom_rect(aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = id),
color = "black", linewidth = 0.4) +
geom_text(aes(x = (xmin + xmax) / 2, y = (ymin + ymax) / 2, label = label), size = 3) +
coord_fixed(xlim = c(0, N), ylim = c(0, N), expand = FALSE) +
theme_void() +
guides(fill = "none") +
ggtitle(paste0("Mondrian tiling (N = ", N, ")"))
}
source("mondrian_utils.R")
source("mondrian_solver.R")
source("mondrian_viz.R")
# Install if needed:
# install.packages("ggplot2")
N <- 6  # try 5..8 to start
res <- solve_mondrian(N, max_partitions = 500L)
cat("Best defect M(", N, ") = ", res$best_defect, "\n", sep = "")
print(plot_tiling(N, res$tiling))
N <- 7  # try 5..8 to start
res <- solve_mondrian(N, max_partitions = 500L)
cat("Best defect M(", N, ") = ", res$best_defect, "\n", sep = "")
print(plot_tiling(N, res$tiling))
N <- 8  # try 5..8 to start
res <- solve_mondrian(N, max_partitions = 500L)
cat("Best defect M(", N, ") = ", res$best_defect, "\n", sep = "")
print(plot_tiling(N, res$tiling))
N <- 10  # try 5..8 to start
res <- solve_mondrian(N, max_partitions = 500L)
cat("Best defect M(", N, ") = ", res$best_defect, "\n", sep = "")
print(plot_tiling(N, res$tiling))
getwd()
setwd("/Users/gn/work/projects/github_blitz_aug13_18/day4/mondrian_problem/phase_4/")
# ---- Mondrian Utilities ----
# Candidate areas from non-congruent rectangles up to N (forbid N x N)
candidate_areas <- function(N) {
A <- integer()
for (a in 1L:N) for (b in a:N) {
if (a == N && b == N) next
A <- c(A, a * b)
}
sort(unique(A))
}
# Factor pairs for a given area within N.
# RETURNS: list of lists, each like list(w=ww, h=hh, area=area).
factor_pairs_for_area <- function(area, N) {
out <- list()
for (w in 1L:min(N, floor(sqrt(area)))) {
if (area %% w == 0L) {
h <- area %/% w
if (h <= N) {
ww <- min(w, h); hh <- max(w, h)
out[[length(out) + 1L]] <- list(w = ww, h = hh, area = area)
}
}
}
# de-duplicate unordered pairs
if (!length(out)) return(list())
keys <- vapply(out, function(z) paste0(z$w, "x", z$h), "")
out[!duplicated(keys)]
}
# Enumerate distinct-area subsets S with sum S == N^2 (ordered by defect).
partitions_distinct_sum <- function(N, max_sets = 200L) {
target <- N * N
A <- candidate_areas(N)
out <- list(); cur <- integer()
backtrack <- function(i, remain) {
if (length(out) >= max_sets) return()
if (remain == 0L && length(cur) >= 2L) {
out[[length(out) + 1L]] <<- sort(cur)
return()
}
if (i > length(A) || remain < 0L) return()
a <- A[i]
if (a <= remain) { cur <<- c(cur, a); backtrack(i + 1L, remain - a); cur <<- cur[-length(cur)] }
backtrack(i + 1L, remain)
}
backtrack(1L, target)
if (!length(out)) return(list())
ord <- order(vapply(out, function(s) max(s) - min(s), numeric(1)))
out[ord]
}
# ---- DLX Exact Cover (Algorithm X) ----
# Build rows for exact cover:
# - Columns 1..N^2: board cells (must be covered exactly once)
# - Columns N^2+1..N^2+R: one column per rectangle (use each rectangle exactly once)
# rects: list of list(w,h,area)
build_exact_cover_rows <- function(N, rects) {
n_cells <- N * N
rows <- list()
for (k in seq_along(rects)) {
r <- rects[[k]]
# unique orientations (avoid duplicate if w==h)
orients <- if (r$w == r$h) list(c(r$w, r$h)) else list(c(r$w, r$h), c(r$h, r$w))
for (o in orients) {
w <- o[1]; h <- o[2]
for (row in 1:(N - h + 1)) for (col in 1:(N - w + 1)) {
cells <- as.vector(outer((row - 1):(row + h - 2), (col - 1):(col + w - 2),
function(rr, cc) rr * N + cc + 1L))
rows[[length(rows) + 1L]] <- c(cells, n_cells + k)
}
}
}
rows
}
# Simple Algorithm X (sufficient for N up to ~8–10 with the arithmetic filter).
algorithm_x <- function(rows, ncols, max_solutions = 1L) {
col_rows <- vector("list", ncols)
for (ri in seq_along(rows)) for (c in rows[[ri]]) col_rows[[c]] <- c(col_rows[[c]], ri)
used_rows <- logical(length(rows))
used_cols <- logical(ncols)
solution  <- integer(0)
solutions <- list()
choose_col <- function() {
best_c <- 0L; best_len <- Inf
for (c in which(!used_cols)) {
cand <- col_rows[[c]]; cand <- cand[!used_rows[cand]]
ln <- length(cand)
if (ln < best_len) { best_len <- ln; best_c <- c }
if (best_len == 0L) break
}
best_c
}
cover <- function(ri) {
rcols <- rows[[ri]]
stashed <- vector("list", length(rcols))
for (i in seq_along(rcols)) {
c <- rcols[[i]]
if (used_cols[c]) next
used_cols[c] <<- TRUE
bad <- col_rows[[c]]; bad <- bad[!used_rows[bad]]
stashed[[i]] <- bad
used_rows[bad] <<- TRUE
}
stashed
}
uncover <- function(ri, stashed) {
rcols <- rows[[ri]]
for (i in seq_along(rcols)) {
c <- rcols[[i]]
used_cols[c] <<- FALSE
used_rows[stashed[[i]]] <<- FALSE
}
}
search <- function() {
if (all(used_cols)) {
solutions[[length(solutions) + 1L]] <<- solution
return(length(solutions) < max_solutions)
}
c <- choose_col()
if (c == 0L) return(TRUE)
candidates <- col_rows[[c]]; candidates <- candidates[!used_rows[candidates]]
if (!length(candidates)) return(TRUE)
for (ri in candidates) {
solution <<- c(solution, ri)
stash <- cover(ri)
cont <- search()
uncover(ri, stash)
solution <<- solution[-length(solution)]
if (!cont) return(FALSE)
}
TRUE
}
search()
solutions
}
# ---- Rehydrate a DLX solution into rectangle placements for plotting ----
rehydrate_solution <- function(N, rects, rows, sol_rows) {
# Build the same linear order mapping we used in build_exact_cover_rows()
inv <- vector("list", length(rows))
idx <- 0L
for (k in seq_along(rects)) {
r <- rects[[k]]
orients <- if (r$w == r$h) list(c(r$w, r$h)) else list(c(r$w, r$h), c(r$h, r$w))
for (o in orients) {
w <- o[1]; h <- o[2]
for (row in 1:(N - h + 1)) for (col in 1:(N - w + 1)) {
idx <- idx + 1L
inv[[idx]] <- list(row = row, col = col, w = w, h = h, area = r$area, id = k)
}
}
}
til <- lapply(sol_rows, function(ri) inv[[ri]])
ord <- order(vapply(til, `[[`, integer(1), "row"),
vapply(til, `[[`, integer(1), "col"))
til[ord]
}
library(ggplot2)
plot_tiling <- function(N, tiling) {
if (is.null(tiling)) {
return(ggplot() + ggtitle("No tiling found") + theme_void())
}
rects <- tiling$rects
rows  <- tiling$rows
sol   <- tiling$sol
placed <- rehydrate_solution(N, rects, rows, sol)
df <- do.call(rbind, lapply(seq_along(placed), function(i) {
r <- placed[[i]]
data.frame(
xmin = r$col - 1, xmax = r$col - 1 + r$w,
ymin = r$row - 1, ymax = r$row - 1 + r$h,
id = factor(i), label = paste0(r$w, "x", r$h)
)
}))
ggplot(df) +
geom_rect(aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = id),
color = "black", linewidth = 0.4) +
geom_text(aes(x = (xmin + xmax) / 2, y = (ymin + ymax) / 2, label = label), size = 3) +
coord_fixed(xlim = c(0, N), ylim = c(0, N), expand = FALSE) +
theme_void() +
guides(fill = "none") +
ggtitle(paste0("Mondrian tiling (N = ", N, ")"))
}
# ---- Hybrid Mondrian Solver (Min-defect guaranteed across tried partitions) ----
source("mondrian_utils.R")
.fp_to_wh <- function(fp) {
if (is.list(fp)) {
if (!is.null(fp$w) && !is.null(fp$h)) return(c(as.integer(fp$w), as.integer(fp$h)))
x <- unlist(fp, use.names = FALSE); return(c(as.integer(x[1]), as.integer(x[2])))
} else {
return(c(as.integer(fp[1]), as.integer(fp[2])))
}
}
# Try all factor-pair assignments for a partition S; return first DLX tiling found (or NULL)
.try_all_factor_assignments <- function(N, S) {
m <- length(S)
# Precompute options per area
options <- vector("list", m)
for (i in seq_len(m)) {
fps <- factor_pairs_for_area(S[i], N)
if (!length(fps)) return(NULL)  # impossible partition (some area has no pair)
# normalize to (w,h)
options[[i]] <- lapply(fps, .fp_to_wh)
}
rects <- vector("list", m)
used_shapes <- new.env(parent = emptyenv())  # (w,h) keys if you also want to forbid same dims (redundant since areas are distinct)
ncols <- N * N
# backtrack over assignments
assign_rec <- function(k) {
if (k > m) {
# All assigned: run DLX
rows <- build_exact_cover_rows(N, rects)
sols <- algorithm_x(rows, ncols + length(rects), max_solutions = 1L)
if (length(sols)) {
return(list(rects = rects, rows = rows, sol = sols[[1]]))
}
return(NULL)
}
# iterate options for area S[k]
for (wh in options[[k]]) {
key <- paste0(wh[1], "x", wh[2])
# optional: forbid duplicate shapes; with distinct areas it's unnecessary, but harmless
if (!is.null(used_shapes[[key]])) next
rects[[k]] <<- list(w = wh[1], h = wh[2], area = S[k])
used_shapes[[key]] <- TRUE
ans <- assign_rec(k + 1L)
if (!is.null(ans)) return(ans)
rm(list = key, envir = used_shapes)
rects[[k]] <<- NULL
}
NULL
}
assign_rec(1L)
}
solve_mondrian <- function(N, max_partitions = 2000L) {
# Get partitions sorted by increasing defect
parts <- partitions_distinct_sum(N, max_partitions)
if (!length(parts)) {
return(list(best_defect = Inf, tiling = NULL))
}
# Group partitions by defect so we can ensure minimality
defects <- vapply(parts, function(S) max(S) - min(S), numeric(1))
uniq_def <- sort(unique(defects))
best_defect <- Inf
best <- NULL
for (D in uniq_def) {
# consider only partitions with this defect
idx <- which(defects == D)
# try each partition S of defect D; for each, try all factor-pair assignments
for (j in idx) {
S <- parts[[j]]
til <- .try_all_factor_assignments(N, S)
if (!is.null(til)) {
best_defect <- D
best <- til
# Since we sweep by increasing D, the first success is truly minimal defect
return(list(best_defect = best_defect, tiling = best))
}
}
# continue to next defect level if none feasible at this D
}
# none feasible among enumerated partitions
list(best_defect = Inf, tiling = NULL)
}
source("mondrian_utils.R")
source("mondrian_solver.R")
source("mondrian_viz.R")
# Install if needed:
# install.packages("ggplot2")
N <- 6  # try 5..8 to start
res <- solve_mondrian(N, max_partitions = 500L)
cat("Best defect M(", N, ") = ", res$best_defect, "\n", sep = "")
print(plot_tiling(N, res$tiling))
N <- 9  # try 5..8 to start
res <- solve_mondrian(N, max_partitions = 500L)
cat("Best defect M(", N, ") = ", res$best_defect, "\n", sep = "")
print(plot_tiling(N, res$tiling))
N <- 10  # try 5..8 to start
res <- solve_mondrian(N, max_partitions = 500L)
cat("Best defect M(", N, ") = ", res$best_defect, "\n", sep = "")
print(plot_tiling(N, res$tiling))
N <- 11  # try 5..8 to start
res <- solve_mondrian(N, max_partitions = 500L)
cat("Best defect M(", N, ") = ", res$best_defect, "\n", sep = "")
print(plot_tiling(N, res$tiling))
N <- 16  # try 5..8 to start
res <- solve_mondrian(N, max_partitions = 500L)
cat("Best defect M(", N, ") = ", res$best_defect, "\n", sep = "")
print(plot_tiling(N, res$tiling))
